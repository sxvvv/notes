# 矩阵乘法初步

## 一、矩阵乘法的数学定义
矩阵乘法是线性代数中最核心的运算之一，也是深度学习、科学计算等领域（如神经网络的全连接层）的基石。理解其底层实现与优化逻辑，对于掌握高性能计算至关重要。
其数学定义如下：

- 输入：矩阵 A（维度 $M \times K$）与矩阵B（维度 $K \times N$）。

- 输出：矩阵 $C= A \times B$ (维度 $M \times N$)

这里，轴 K 被称为“规约轴”（Reduction Axis），因为它在求和过程中被“规约”掉了。

## 二、初步实现：三重循环的直观理解

```python
def matrix_multiply(A, B):
    rows_A, cols_A = A.shape  # M, K
    rows_B, cols_B = B.shape  # K, N
    assert cols_A == rows_B  # 维度匹配检查
    C = np.zeros((rows_A, cols_B))  # 初始化结果矩阵
    for i in range(rows_A):      # 遍历 M 轴（输出的行）
        for j in range(cols_B):  # 遍历 N 轴（输出的列）
            for k in range(cols_A): # 遍历 K 轴（规约轴）
                C[i][j] += A[i][k] * B[k][j]
    return C
```
## 三、进阶理解：内存访问与性能优化

为什么通常将规约轴 K 放在最内层？这涉及到计算机体系结构中的**缓存局部性原理**。

- 内存布局与访问模式

    - 行优先存储：在C语言、NumPy等环境中，矩阵在内存中是按行连续存储的。

    - 访问效率：

        - A[i][k]的访问：当 k 递增时，访问的是连续的内存地址，缓存命中率高。

        - B[k][j]的访问：当 k 递增时，访问的是 B 的第 j 列，这在内存中是非连续的（跳跃式访问），容易导致缓存未命中。

    - 当前实现

        - 优点：A[i][k]连续访问，C[i][j]被反复复用（在内层循环中累加）。

        - 缺点：B[k][j]非连续访问。

    - **优化方向：分块（Tiling/Blocking）**

    当矩阵很大时，即使 i−j−k 顺序也可能因缓存容量不足而性能下降。此时，可将矩阵划分为小块（如 $32 \times 32$），使每个块能完全放入缓存，从而大幅提升计算效率。


# 分块矩阵

## 一、核心思想：化整为零与缓存友好

朴素矩阵乘法中，我们直接通过三重循环遍历整个矩阵。当矩阵规模较大时（如$512\times512$或更大），由于CPU缓存（Cache）容量有限，数据在内存与缓存之间频繁换入换出（即“缓存未命中”），导致计算效率急剧下降。

分块矩阵乘法的核心思想是 “局部性原理” ：

    1. 空间局部性：将大矩阵划分为若干个大小适中的“块”（Block/Tile），使得单个块能够完全容纳于CPU的一级缓存（L1 Cache）或寄存器中。
    
    2. 时间局部性：在计算某个输出块时，重复利用已加载到缓存中的输入块数据，减少对主存的访问次数。

## 二、数学与代码的对应拆解

1. 外层循环：定位输出块

代码中的前两层循环负责确定我们正在计算结果矩阵C的哪一个“格子”。

- 几何意义：想象矩阵C被划分为一个 $frac{M}_{BLOCK_{SIZE}} \times frac{N}_{BLOCK_{SIZE}}$ 的网格。变量m和n代表当前处理的网格单元的左上角坐标。

- 数据结构：此时，我们为这个网格单元分配一个临时的“工作台”（累加器acc），用于暂存计算结果。

2. 内层规约：拼图累加过程

这是分块乘法中最关键的一步，对应矩阵乘法的“行 $\times$ 列”累加过程，但在块级别上进行。

```python
acc = np.zeros((BLOCK_SIZE, BLOCK_SIZE))
for k in range(0, K, BLOCK_SIZE):
    a = A[m: m + BLOCK_SIZE, k: k + BLOCK_SIZE]
    b = B[k: k + BLOCK_SIZE, n: n + BLOCK_SIZE]
    acc += np.dot(a, b)
```

计算流程：
    - 目标：计算C左上角的第一个$16\times16$块。
    
    - 步骤1：取A左上角的$16\times16$块（A_{0,0}）与B第一行第一列的$16\times16$块（B_{0,0}）相乘，结果放入acc。
    
    - 步骤2：取A第一行第二列的块（A_{0,1}）与B第二行第一列的块（B_{1,0}）相乘，累加到acc。
    
    - 步骤3：继续此过程，直到A的第一行块与B的第一列块全部计算完毕。

    - 结果：acc中存储的就是C左上角块的最终结果。

在分块版本中，当我们加载块a和b时，我们访问的是连续的内存区域（因为切片操作提取了连续的子矩阵）。这使得CPU缓存能够预取数据，极大地减少了等待数据从主存加载的时间。

